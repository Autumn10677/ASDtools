{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#asdtools","title":"ASDtools","text":"<p>This package relies heavily on astroquery.nist's querying capabilities for loading spectral data for a given element over a range of wavelengths. The main advantage of ASDtools is its ability to format astroquery's default output into a formatted DataFrame. Additionally, I have made a handful of helpful tools for visualizing several pieces of the NIST ASD. This package's primary goal is to help users understand and visualize standard conventions in atomic spectroscopy.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install ASDtools on your device, run the following command on your system's terminal.</p> <pre><code>pip install ASDtools\n</code></pre> <p>If you have a previous version of ASDtools on your device and would like to upgrade to the latest official release, use the following command.</p> <pre><code>pip install --upgrade ASDtools\n</code></pre> <p>Currently, ASDtools has the following dependencies...</p> <pre><code>'astropy',\n'astroquery',\n'Fraction',\n'ipython!=8.17.1,&lt;9.0.0,&gt;=8.13.0',\n'matplotlib',\n'numpy&lt;2',\n'pandas',\n'periodictable',\n'roman',\n'sympy',\n'tqdm'\n</code></pre>"},{"location":"filling/","title":"Electron Configuration","text":"<p>There are a few useful terms to remember when describing the configuration of electrons around an atom...</p> <ul> <li><code>shells</code>: Electrons w/ a shared principal quantum number</li> <li><code>subshells</code>: Electrons w/ a shared shell and angular momentum quantum number</li> <li><code>orbitals</code>: Electrons w/ a shared shell, subshell, and magnetic quantum number</li> </ul> <p>Each orbital can hold two electrons due to the Pauli exclusion principle, meaning we can reliably calculate how many electrons a given subshell/shell can hold! However, electrons will fill up each orbital/subshell/shell in a very particular way.</p> In\u00a0[1]: Copied! <pre>import ASDtools as asdt\n\nasdt.draw_aufbau_diagram(N_max=5)\n</pre> import ASDtools as asdt  asdt.draw_aufbau_diagram(N_max=5) <p>Notice how some subshells with a higher n sometimes fill before subshells of a lower n (i.e., 4s fills before 3d). These subshells (despite having a larger n) have a lower associated energy. Electrons will always fill the lowest-energy subshell, regardless of the principal quantum number! Finding the exact energies of each subshell is tricky, and analytical solutions are only known for the lightest of elements.</p> <p>From the above Aufbau diagram, we are able to predict the order that electrons fill into each subshell. Note that there are exceptions to the Aufbau principle where electrons fill in an order the above diagram cannot predict. These exceptions are not currently accounted for in ASDtools.</p> In\u00a0[2]: Copied! <pre>asdt.find_filling_order(max_level=5, joined=True)\n</pre> asdt.find_filling_order(max_level=5, joined=True) Out[2]: <pre>'1s.2s.2p.3s.3p.4s.3d.4p.5s'</pre> <p>What if we wanted to know the ground-state electronic configuration of a given element and ionization? To do this, we need to know the total number of available electrons how many electrons can fill into each subshell. The first of these two is simple to calculate...</p> \\begin{equation} (\\textrm{# of available electrons}) = (\\textrm{# of protons}) - (\\textrm{# of ionized electrons}) \\end{equation}<p>The electron capacity of each subshell is also fairly straightforward. Each subsequent subshell has two additional orbitals. So...</p> Orbital Total Orbitals Total e s 1 2 p 3 6 d 5 10 f 7 14 $$\\vdots$$ $$\\vdots$$ $$\\vdots$$ <p>The following function uses this logic to convert elements (with formatting identical to the NIST ASD's) into a ground-state configuration. Note, this function allows for abbreviated notation and two different sorting schemes (\"fill order\" and \"principle\"). The NIST ASD defaults to \"principle\" sorting.</p> In\u00a0[3]: Copied! <pre>asdt.find_electronic_config(\"O I\", abbreviate=True, sortby=\"fill order\")\n</pre> asdt.find_electronic_config(\"O I\", abbreviate=True, sortby=\"fill order\") Out[3]: <pre>'[He]2s2.2p4'</pre> <p>There are situations where it may be helpful to tell whether a given subshell is filled or not. The following function takes a subshell string and determines whether it is at capacity.</p> In\u00a0[4]: Copied! <pre>subshell_one = \"2p3\"\nsubshell_two = \"2p6\"\n\nprint(f\"Subshell '{subshell_one}' is filled: {asdt.is_subshell_filled(subshell_one)}\")\nprint(f\"Subshell '{subshell_two}' is filled: {asdt.is_subshell_filled(subshell_two)}\")\n</pre> subshell_one = \"2p3\" subshell_two = \"2p6\"  print(f\"Subshell '{subshell_one}' is filled: {asdt.is_subshell_filled(subshell_one)}\") print(f\"Subshell '{subshell_two}' is filled: {asdt.is_subshell_filled(subshell_two)}\") <pre>Subshell '2p3' is filled: False\nSubshell '2p6' is filled: True\n</pre> <p>If we look at the ASD's electronic configurations for heavy elements, there appears to be an odd format that doesn't follow the conventions laid out above. Take the following configuration data for \"Ni I,\" for example. In addition to traditional subshells, there are terms contained within parentheses. These relate to another way of describing atoms: term symbols.</p> In\u00a0[5]: Copied! <pre>import numpy as np\n\nlines = asdt.NIST_lines([\"Ni I\"], keep_flag_columns=True, update=False)\nnp.unique(lines.df[\"Lower level\"])[:10]\n</pre> import numpy as np  lines = asdt.NIST_lines([\"Ni I\"], keep_flag_columns=True, update=False) np.unique(lines.df[\"Lower level\"])[:10] Out[5]: <pre>array(['3d10                 | 1S   | 0',\n       '3d8.(1D).4s.4p.(3P*) | 3F*  | 3',\n       '3d8.(1D).4s2         | 1D   | 2',\n       '3d8.(1G).4s2         | 1G   | 4',\n       '3d8.(3F).4s.4p.(1P*) | 3F*  | 4',\n       '3d8.(3F).4s.4p.(1P*) | 3G*  | 4',\n       '3d8.(3F).4s.4p.(3P*) | 1D*  | 2',\n       '3d8.(3F).4s.4p.(3P*) | 1F*  | 3',\n       '3d8.(3F).4s.4p.(3P*) | 1G*  | 4',\n       '3d8.(3F).4s.4p.(3P*) | 3D*  | 1'], dtype=object)</pre>"},{"location":"filling/#what-is-an-aufbau-diagram","title":"What is an Aufbau Diagram?\u00b6","text":"<p>To understand this filling order, we need to understand the Aufbau principle. In particular, the \"diagonal rule,\" which describes how electrons will fill each subshell in an atom's ground-state configuration. Start from the bottom left (at the \"1s\") and follow the arrow to the left. Then, start back up at the next highest arrow. This visual trick allows us to predict how electrons sort into each subshell.</p>"},{"location":"filling/#electron-configuration","title":"Electron Configuration\u00b6","text":""},{"location":"flags/","title":"Understanding the DataFrame","text":"<p>Although the DataFrames produced by ASDtools are similar to those from astroquery.NIST, there a handful of differences. The following sections identify each column, their meaning, and one mechanism for checking the accuracy of the processed data.</p> In\u00a0[1]: Copied! <pre>import ASDtools as asdt\n</pre> import ASDtools as asdt In\u00a0[2]: Copied! <pre>lines = asdt.NIST_lines(\"He I\", \n                        keep_original_columns=True, \n                        update=False)\nlines.df.head()\n</pre> lines = asdt.NIST_lines(\"He I\",                          keep_original_columns=True,                          update=False) lines.df.head() Out[2]: Element Observed_original Observed (nm) Ritz_original Ritz (nm) Transition Type Rel._original Rel. Ei (eV)_original Ei (eV) ... Aki_original Aki gi_original gi gk_original gk S Acc. Lower level Upper level 0 He I 32.02926 32.02926 32.02935 32.029350 E1 10* 10.0 [20.96421885051] 20.964219 ... nan NaN 1 1.0 9 9.0 NaN 1s.2p  | 3P*  | 0 2p2    | 3P   | 0,1,2 1 He I 32.02926 32.02926 32.02925 32.029250 E1 10* 10.0 [20.96409636464] 20.964096 ... nan NaN 3 3.0 9 9.0 NaN 1s.2p  | 3P*  | 1 2p2    | 3P   | 0,1,2 2 He I 32.02926 32.02926 32.02924 32.029240 E1 10* 10.0 [20.96408688908] 20.964087 ... nan NaN 5 5.0 9 9.0 NaN 1s.2p  | 3P*  | 2 2p2    | 3P   | 0,1,2 3 He I 50.561 50.56100 50.5500354 50.550035 E1 2 2.0 [0.00000000] 0.000000 ... nan NaN 1 1.0 3 3.0 NaN 1s2    | 1S   | 0 1s.15p | 1P*  | 1 4 He I 50.575 50.57500 50.5684333 50.568433 E1 3 3.0 [0.00000000] 0.000000 ... nan NaN 1 1.0 3 3.0 NaN 1s2    | 1S   | 0 1s.14p | 1P*  | 1 <p>5 rows \u00d7 22 columns</p> <p>The original columns all have the naming convention \"{column}_original.\" Certain columns (i.e., \"Element,\" \"S,\" \"Lower level,\" \"Upper level\") do not have an \"original\" column since they have not been altered or are not a defult astroquery output.</p> In\u00a0[3]: Copied! <pre>lines = asdt.NIST_lines(\"Ne II\", \n                        keep_flag_columns=True, \n                        keep_original_columns=True, \n                        update=False)\nlines.df.head()\n</pre> lines = asdt.NIST_lines(\"Ne II\",                          keep_flag_columns=True,                          keep_original_columns=True,                          update=False) lines.df.head() Out[3]: Element Observed_original Observed (nm) Ritz_original Ritz (nm) Transition Type Rel._original Rel. Rel._flags Ei (eV)_original ... Aki_original Aki gi_original gi gk_original gk S Acc. Lower level Upper level 0 Ne II 28.6308 28.6308 28.6308 28.63080 E1 6 6.0 NaN 0.00000000 ... nan NaN 4 4.0 2 2.0 NaN 2s2.2p5            | 2P*   | 3/2 2s2.2p4.(1D).8d    | 2S    | 1/2 1 Ne II nan NaN 28.6949 28.69490 E1 m NaN [m] 0.09676024 ... nan NaN 2 2.0 2 2.0 NaN 2s2.2p5            | 2P*   | 1/2 2s2.2p4.(1D).8d    | 2S    | 1/2 2 Ne II 28.8073 28.8073 28.80732 28.80732 E1 12 12.0 NaN 0.00000000 ... nan NaN 4 4.0 2 2.0 NaN 2s2.2p5            | 2P*   | 3/2 2s2.2p4.(1D).7d    | 2S    | 1/2 3 Ne II 28.872 28.8720 28.8722 28.87220 E1 6 6.0 NaN 0.09676024 ... nan NaN 2 2.0 2 2.0 NaN 2s2.2p5            | 2P*   | 1/2 2s2.2p4.(1D).7d    | 2S    | 1/2 4 Ne II 29.0831 29.0831 29.083 29.08300 E1 48 48.0 NaN 0.00000000 ... nan NaN 4 4.0 2 2.0 NaN 2s2.2p5            | 2P*   | 3/2 2s2.2p4.(1D).6d    | 2S    | 1/2 <p>5 rows \u00d7 24 columns</p> <p>If you want to see which flags were identified within your data, along with their total number of occurences and meaning, a helper function will attempt to do just that!</p> In\u00a0[4]: Copied! <pre>lines.explain_column_flags(\"Rel.\")\n</pre> lines.explain_column_flags(\"Rel.\") <pre>   Flag: *\n Counts: 101\nMeaning: Intensity is shared by several lines (typically, for multiply classified lines).\n\n   Flag: ?\n Counts: 7\nMeaning: This level/line may not be real.\n\n   Flag: bl\n Counts: 83\nMeaning: Blended with another line that may affect the wavelength and intensity.\n\n   Flag: c\n Counts: 3\nMeaning: Complex line.\n\n   Flag: l\n Counts: 1\nMeaning: Shaded to longer wavelengths; NB: This may look like a 'one' at the end of the number!\n\n   Flag: m\n Counts: 9\nMeaning: Masked by another line (no wavelength measurement).\n\n   Flag: s\n Counts: 1\nMeaning: Shaded to shorter wavelengths.\n\n   Flag: w\n Counts: 46\nMeaning: Wide line.\n\n</pre>"},{"location":"flags/#basic-dataframe-format","title":"Basic DataFrame Format\u00b6","text":"<p>The default DataFrame produced by ASDtools has 14 columns...</p> <ol> <li><code>Element</code>: The element symbol and ionization for a given row.</li> <li><code>Observed (nm)</code>: The vacuum wavelength this line has been observed at.</li> <li><code>Ritz (nm)</code>: The Ritz wavelength inferred from the energy levels of the transition.</li> <li><code>Transition Type</code>: Indicates the type of transition rules necessary for the transition (i.e., E1, E2, M1, etc.).</li> <li><code>Rel.</code>: The qualitative relative intensity of lines.</li> <li><code>Ei (eV)</code>: Energy of the lower level (in eV).</li> <li><code>Ek (eV)</code>: Energy of the upper level (in eV).</li> <li><code>Aki</code>: Emission transition probability</li> <li><code>gi</code>: Lower level statistical weight.</li> <li><code>gk</code>: Upper level statistical weight.</li> <li><code>S</code>: Line strength (electric dipole matrix element squared).</li> <li><code>Acc.</code>: 'Accuracy' of the given transition strength (see NIST help doc).</li> <li><code>Lower level</code>: Electronic configuration, term symbol, and J-value of the lower level.</li> <li><code>Upper level</code>: Electronic configuration, term symbol, and J-value of the upper level.</li> </ol> <p>To arrive at the final DataFrame of ASDtools, several columns have to be filtered / processed. For several columns, this only requires the column to be converted into the appropriate data type. But, several columns feature flags, where are any non-numeric character that communicate information about the line in question. Although ASDtools has been extensively tested, there is still a possibility that the numerical values in this DataFrame are extracted incorrectly. So, using <code>keep_original_columns = True</code> you can manually check its accuracy by choosing to keep a copy of each column before any processing was applied.</p>"},{"location":"flags/#all-nist-provided-flags","title":"All NIST-Provided Flags\u00b6","text":"<p>If the user uses the <code>keep_flag_columns = True</code> argument, ASDtools will attempt to extract and filter out \"flags\" found within the DataFrame. The term \"flag\" refers to any non-numeric entry in numeric columns. These are not filtered out by astroquery, meaning they can interfere with using data directly from the NIST ASD without extra filtering. Flags are stored as a list in a new column with the naming convention \"{column}_flags.\" Their meanings are all pulled from the NIST ASD Help Page.</p> <ul> <li><code>*</code>: Intensity is shared by several lines (typically, for multiply classified lines).</li> <li><code>:</code>: Observed value given is actually the rounded Ritz value, e.g., Ar IV, \u03bb = 443.40 \u00c5.</li> <li><code>-</code>: Somewhat lower intensity than the value given.</li> <li><code>?</code>: This level/line may not be real.</li> <li><code>\u2020</code>: Term assignment of the level is questionable.</li> <li><code>a</code>: Observed in absorption.</li> <li><code>bl</code>: Blended with another line that may affect the wavelength and intensity.\"</li> <li><code>b</code>: Band head.</li> <li><code>B</code>: Line or feature having large width due to autoionization broadening.</li> <li><code>c</code>: Complex line.</li> <li><code>d</code>: Diffuse line.</li> <li><code>D</code>: Double line.</li> <li><code>E</code>: Broad due to overexposure in the quoted reference.</li> <li><code>f</code>: Forbidden line.</li> <li><code>g</code>: Transition involving a level of the ground term.</li> <li><code>G</code>: Line position roughly estimated.</li> <li><code>H</code>: Very hazy line.</li> <li><code>hfs</code>: Line has hyperfine structure.</li> <li><code>h</code>: Hazy line (same as 'diffuse').</li> <li><code>i</code>: Identification uncertain.</li> <li><code>j</code>: Wavelength smoothed along isoelectronic sequence.</li> <li><code>l</code>: Shaded to longer wavelengths; NB: This may look like a 'one' at the end of the number!</li> <li><code>m</code>: Masked by another line (no wavelength measurement).</li> <li><code>p</code>: Perturbed by a close line. Both wavelength and intensity may be affected.</li> <li><code>q</code>: Asymmetric line.</li> <li><code>r</code>: Easily reversed line.</li> <li><code>s</code>: Shaded to shorter wavelengths.</li> <li><code>t</code>: Tentatively classified line.</li> <li><code>u</code>: Unresolved from a close line.</li> <li><code>+x</code> : The relative positions of the levels within such a system are accurate within experimental uncertainties, but no experimental connection between this system and the other levels of the spectrum has been made.</li> <li><code>+y</code> : The relative positions of the levels within such a system are accurate within experimental uncertainties, but no experimental connection between this system and the other levels of the spectrum has been made.</li> <li><code>+z</code> : The relative positions of the levels within such a system are accurate within experimental uncertainties, but no experimental connection between this system and the other levels of the spectrum has been made.</li> <li><code>w</code>: Wide line.</li> <li><code>x</code>: Extrapolated wavelength.</li> <li><code>()</code> : Theoretical value.</li> <li><code>[]</code> : This level was determined by interpolation or extrapolation of known experimental values or by semiempirical calculation.</li> </ul>"},{"location":"grotrian/","title":"Grotrian Diagrams","text":"<p>While there are many ways to visualize the spectral lines for a given element, Grotrian diagrams are a popular choice among research scientists. Generally, Grotrian diagrams will the energy levels of each transition as a function of the corresponding term symbols. Currently, ASDtools is only capable of one sorting schema. Each term is sorted according to increasing multiplicity, total orbital angular momentum, and parity. To generate the Grotrian diagram, you just need to provide an element and ionization.</p> In\u00a0[1]: Copied! <pre>import ASDtools as asdt\n\nasdt.draw_grotrian_diagram(\"H I\", update=False)\n</pre> import ASDtools as asdt  asdt.draw_grotrian_diagram(\"H I\", update=False) <p>Additional arguments allow you to filter for lines that meet a certain criteria. For example...</p> <ul> <li><code>min_energy</code>: Minimum energy (eV) to plot.</li> <li><code>max_energy</code>: Maximum energy (eV) to plot.</li> <li><code>min_multiplicity</code>: Minimum multiplicity to plot.</li> <li><code>max_multiplicity</code>: Maximum multiplicity to plot.</li> <li><code>min_letter</code>: Minimum letter (L) to plot.</li> <li><code>max_letter</code>: Maximum letter (L) to plot.</li> </ul> <p>If no value is provided for the above arguments, that limit is assumed to be unbounded.</p> In\u00a0[2]: Copied! <pre>asdt.draw_grotrian_diagram(\"O II\", \n                           min_energy=4,\n                           max_energy=30,\n                           update=False)\n</pre> asdt.draw_grotrian_diagram(\"O II\",                             min_energy=4,                            max_energy=30,                            update=False)"},{"location":"query/","title":"How to Query","text":"<p>This package relies on astroquery.NIST for querying spectral line data, so it takes similar arguments. All data querying, processing, and formatting happens within a class called <code>NIST_lines</code>. To pull all data for a single element, you just need to create an instance of this class with the desired elemental symbol as an argument.</p> In\u00a0[1]: Copied! <pre>import ASDtools as asdt\n\nlines = asdt.NIST_lines(\"He\", update=False)\nlines.df.head()\n</pre> import ASDtools as asdt  lines = asdt.NIST_lines(\"He\", update=False) lines.df.head() Out[1]: Element Observed (nm) Ritz (nm) Transition Type Rel. Ei (eV) Ek (eV) Aki gi gk S Acc. Lower level Upper level 0 He II NaN 23.434716 E1 NaN 0.0 52.906209 3.158600e+08 2.0 4.0 0.000008 AA 1s     | 2S   | 1/2 6p     | 2P*  | 3/2 1 He II NaN 23.434728 E1 NaN 0.0 52.906182 3.158300e+08 2.0 2.0 0.000004 AA 1s     | 2S   | 1/2 6p     | 2P*  | 1/2 2 He II NaN 23.733066 E1 NaN 0.0 52.241121 5.503600e+08 2.0 4.0 0.000015 AA 1s     | 2S   | 1/2 5p     | 2P*  | 3/2 3 He II NaN 23.733088 E1 NaN 0.0 52.241074 5.503300e+08 2.0 2.0 0.000007 AA 1s     | 2S   | 1/2 5p     | 2P*  | 1/2 4 He II NaN 24.302644 E1 NaN 0.0 51.016752 1.091700e+09 2.0 4.0 0.000031 AA 1s     | 2S   | 1/2 4p     | 2P*  | 3/2 <p>If you want to narrow your query to a specific set of ionizations across a limited wavelength range, that is also possible!</p> In\u00a0[2]: Copied! <pre>import astropy.units as u\n\nlines = asdt.NIST_lines([\"O I\", \"O II\", \"O IV\"], \n                        lower_wavelength=300*u.nm, \n                        upper_wavelength=700*u.nm, \n                        update=False)\nlines.df.head()\n</pre> import astropy.units as u  lines = asdt.NIST_lines([\"O I\", \"O II\", \"O IV\"],                          lower_wavelength=300*u.nm,                          upper_wavelength=700*u.nm,                          update=False) lines.df.head() Out[2]: Element Observed (nm) Ritz (nm) Transition Type Rel. Ei (eV) Ek (eV) Aki gi gk S Acc. Lower level Upper level 0 O I NaN 329.99396 E1 NaN 12.358865 16.116031 143000.0 3.0 1.0 0.000003 D 2s2.2p3.(4S*).4p | 3P   | 1 2s2.2p3.(2D*&lt;3/2&gt;).4d | 3P*  | 0 1 O I NaN 330.05026 E1 NaN 12.358865 16.115390 35700.0 3.0 3.0 0.000002 D 2s2.2p3.(4S*).4p | 3P   | 1 2s2.2p3.(2D*&lt;3/2&gt;).4d | 3P*  | 1 2 O I NaN 330.05114 E1 NaN 12.358875 16.115390 59500.0 5.0 3.0 0.000003 C 2s2.2p3.(4S*).4p | 3P   | 2 2s2.2p3.(2D*&lt;3/2&gt;).4d | 3P*  | 1 3 O I NaN 330.05397 E1 NaN 12.358907 16.115390 47600.0 1.0 3.0 0.000003 D 2s2.2p3.(4S*).4p | 3P   | 0 2s2.2p3.(2D*&lt;3/2&gt;).4d | 3P*  | 1 4 O I NaN 330.15251 E1 NaN 12.358865 16.114226 35700.0 3.0 5.0 0.000003 C 2s2.2p3.(4S*).4p | 3P   | 1 2s2.2p3.(2D*&lt;3/2&gt;).4d | 3P*  | 2"},{"location":"terms/","title":"Term Symbols","text":"<p>When discussing the properties of a given atom, it can be tricky to represent all the relevant quantum-mechanical information. In this section, we will explore a common convention for compactly representing an atom's quantum numbers.</p> In\u00a0[1]: Copied! <pre>import ASDtools as asdt\n</pre> import ASDtools as asdt In\u00a0[2]: Copied! <pre>asdt.generate_term_symbols(\"1s2.2s2.2p2\")\n</pre> asdt.generate_term_symbols(\"1s2.2s2.2p2\") <pre>Term Symbols:\n-------------\n</pre>  $^1S_{0}$   $^3P_{0, 1, 2}$   $^1D_{2}$  In\u00a0[3]: Copied! <pre>asdt.generate_term_symbols(\"1s2.2s1.2d2\")\n</pre> asdt.generate_term_symbols(\"1s2.2s1.2d2\") <pre>Term Symbols:\n-------------\n</pre>  $^2S_{1/2}$   $^2P_{1/2, 3/2}$   $^4P_{1/2, 3/2, 5/2}$   $^2D_{3/2, 5/2}$   $^2F_{5/2, 7/2}$   $^4F_{3/2, 5/2, 7/2, 9/2}$   $^2G_{7/2, 9/2}$  <p>The assumption about LS-coupling is much trickier to account for. For the majority of NIST's spectral lines, this assumption is accurate, so the above function should work. However, for some lines, the reported term symbol uses a different formatting that corresponds with a different coupling schema. Currently, ASDtools has no way of producing term symbols in these situations.</p>"},{"location":"terms/#what-are-term-symbols","title":"What are term symbols?\u00b6","text":"<p>In quantum mechanics, there are four quantum numbers that completely describe an atom.</p> <ul> <li>Principle Quantum Number </li> <li>Orbital Angular Momentum </li> <li>Magnetic Quantum Number </li> <li>Electron Spin Quantum Number </li> </ul> <p>Although we could technically explicitly write out each number for every atomic configuration, term symbols provide a systematic and brief way to describe all four numbers. If you have never encountered term symbols before, please read this helpful page that provides an in-depth explanation of them. Generally, term symbols take the following form...</p> $$ {\\Huge ^\\text{2S+1}\\text{L}_\\text{J}} $$<p>where S is the multiplicity, L is the total orbital angular momentum, and J is the total angular momentum. We need to find all possible values of the above quantum numbers to construct a term symbol for an electronic configuration. Assuming there are n possible ways an electron could be positioned in a subshell, and there are k available electrons, the total number of unique configurations (for a single subshell) is given by the binomial coefficient...</p> \\begin{equation} \\binom{n}{k} = \\frac{n!}{k!(n-k)!}. \\end{equation}<p>However, some of these configurations will produce the same term symbols. This raises an important point: \"term symbols are not an exact description of how electrons are configured in a subshell.\" So, how do we find all the possible term symbols associated with a given electronic configuration? I chose to implement a method outlined in this Wikipedia article, and checked the output against an online calculator. First, we need to write out the value of ML and MS for each possible electron configuration. Let's walk through an example for non-ionized Carbon (1s2.2s2.2p2). Below is a table that finds ML and MS for all possible configurations.</p> $$ \\begin{aligned} &amp;\\begin{array}{|ccc|cc|} \\hline \\textbf { +1 } &amp; \\textbf { 0 } &amp; \\textbf { -1 } &amp; \\text { $M_L$ } &amp; \\text { $M_S$ }\\\\ \\hline \\uparrow &amp; \\uparrow &amp; &amp; 1 &amp; 1\\\\ \\uparrow &amp; &amp; \\uparrow &amp; 0 &amp; 1\\\\  &amp; \\uparrow &amp; \\uparrow &amp; -1 &amp; 1\\\\ \\downarrow &amp; \\downarrow &amp; &amp; 1 &amp; -1\\\\ \\downarrow &amp; &amp; \\downarrow &amp; 0 &amp; -1\\\\  &amp; \\downarrow &amp; \\downarrow &amp; -1 &amp; -1\\\\ \\uparrow \\downarrow &amp; &amp; &amp; 2 &amp; 0\\\\ \\uparrow &amp; \\downarrow &amp; &amp; 1 &amp; 0\\\\ \\uparrow &amp; &amp; \\downarrow &amp; 0 &amp; 0\\\\ \\downarrow &amp; \\uparrow &amp; &amp; 1 &amp; 0\\\\  &amp; \\uparrow \\downarrow&amp; &amp; 0 &amp; 0\\\\  &amp; \\uparrow &amp; \\downarrow &amp; -1 &amp; 0\\\\ \\downarrow &amp; &amp; \\uparrow &amp; 0 &amp; 0\\\\  &amp; \\downarrow &amp; \\uparrow &amp; -1 &amp; 0\\\\  &amp; &amp; \\uparrow \\downarrow &amp; -2 &amp; 0\\\\ \\hline \\end{array} \\end{aligned} $$<p>If we count up the number of configurations that produce each ML and MS, we get the following matrix.</p> $$ \\begin{aligned} &amp;\\begin{array}{|c|ccc|} \\hline &amp; \\textbf { +1 } &amp; \\textbf { 0 } &amp; \\textbf { -1 }\\\\ \\hline \\textbf { +2 } &amp; 0 &amp; 1 &amp; 0 \\\\ \\textbf { +1 } &amp; 1 &amp; 2 &amp; 1 \\\\ \\textbf { 0 } &amp; 1 &amp; 3 &amp; 1 \\\\ \\textbf { -1 } &amp; 1 &amp; 2 &amp; 1 \\\\ \\textbf { -2 } &amp; 0 &amp; 1 &amp; 0 \\\\ \\hline \\end{array} \\end{aligned} $$<p>Each unique term symbol is represented by a sub-matrix of all ones, meaning we can calculate each possible term symbol by finding the minimal set of sub-matrices that comprise the original state matrix. ASDtools achieves this by iteratively finding the largest non-zero submatrix within a calculated state matrix. Then, it converts these sub-matrices into a dataframe of term symbols that are displayed using iPython. An example output is shown below.</p>"},{"location":"terms/#a-small-wrinkle","title":"A Small Wrinkle\u00b6","text":"<p>Technically, the method outlined above only applies under a handful of assumptions...</p> <ol> <li>Only one subhsell is unfilled</li> <li>LS-coupling is the appropriate schema for a given configuration</li> </ol> <p>The first of these are easy to address with a small modification to the method outlined above. If we allow multiple subshells to remain unfilled, then the total number of configurations is given by...</p> \\begin{equation} \\binom{n_1}{k_1} * \\binom{n_2}{k_2} = \\frac{n_1!}{k_1!(n_1-k_1)!} * \\frac{n_2!}{k_2!(n_2-k_2)!} \\end{equation}<p>where k and n are specific to each unfilled subshell. By calculating the quantum numbers for each configuration across all unfilled subshells, we can produce a state matrix that works the same way as above. The function from above automatically handles this extra bit of logic.</p>"}]}